{"version":3,"sources":["js/keyboardController.ts","js/constants.ts","js/vector.ts","js/point.ts","js/line.ts","js/geometry/geometry2d.ts","js/geometry/square.ts","js/geometry/circle.ts","js/character.ts","js/geometry/regularPolygon.ts","js/main.ts"],"names":[],"mappings":"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","file":"main.833bf9d6.js","sourceRoot":"..\\src","sourcesContent":["export enum KeyboardKey {\r\n    W,\r\n    A,\r\n    S,\r\n    D,\r\n};\r\n\r\nconst keyMap: { [key: string]: KeyboardKey } = {\r\n    \"W\": KeyboardKey.W,\r\n    \"A\": KeyboardKey.A,\r\n    \"S\": KeyboardKey.S,\r\n    \"D\": KeyboardKey.D,\r\n};\r\n\r\n// TODO: Update in batches\r\n// Call a method update() on each frame and keep a copy of the arrays\r\n// Provide a wasUpdated() method to reflect changes in eky presses\r\n\r\nclass KeyboardController {\r\n\r\n    private isBind = false;\r\n    //private pressMap: number = 0;\r\n    private pressedArray: KeyboardKey[] = [];\r\n\r\n    constructor() {\r\n        console.debug(\"KeyboardController Ctor\");\r\n    }\r\n\r\n    bind() {\r\n        if (this.isBind) throw new Error(\"Keyboard bind twice\");\r\n        console.debug(\"KeyboardController bind\");\r\n        this.isBind = true;\r\n        document.addEventListener(\"keydown\", this.onKeyDown.bind(this));\r\n        document.addEventListener(\"keyup\", this.onKeyUp.bind(this));\r\n    }\r\n\r\n    isPressed(key: KeyboardKey) {\r\n        return this.pressedArray.includes(key);\r\n        //return (this.pressMap & key) > 0\r\n    }\r\n\r\n    private onKeyDown(event: KeyboardEvent) {\r\n        let key = event.key.toUpperCase();\r\n\r\n        if (typeof(keyMap[key]) !== \"undefined\") {\r\n            this.setPressed(keyMap[key]);\r\n        }\r\n    }\r\n\r\n    private onKeyUp(event: KeyboardEvent) {\r\n        let key = event.key.toUpperCase();\r\n\r\n        if (typeof(keyMap[key]) !== \"undefined\") {\r\n            this.setNotPressed(keyMap[key]);\r\n        }\r\n    }\r\n\r\n    private setPressed(key: KeyboardKey) {\r\n        let idx = this.pressedArray.indexOf(key);\r\n        if (idx >= 0) return;\r\n        this.pressedArray.push(key);\r\n        //this.pressMap |= key;\r\n    }\r\n\r\n    private setNotPressed(key: KeyboardKey) {\r\n        let idx = this.pressedArray.indexOf(key);\r\n        if (idx < 0) return;\r\n        this.pressedArray.splice(idx, 1);\r\n        //this.pressMap &= ~key;\r\n    }\r\n}\r\n\r\nconst INSTANCE = new KeyboardController();\r\n\r\nexport default INSTANCE;","export const CANVAS_WIDTH = 500;\r\nexport const CANVAS_HEIGHT = 500;\r\nexport const MAX_ROUND_ERROR = 10e-5;","import Point from \"./point\";\r\n\r\nexport default class Vector {\r\n    p1?: Point;\r\n    p2?: Nullable<Point>;\r\n\r\n    private _magnitude?: number;\r\n\r\n    // The vector is (v1, v2)\r\n    v1: number;\r\n    v2: number;\r\n    constructor(p1: Point, p2: Point);\r\n    constructor(v1: number, v2: number);\r\n    constructor(pv1: Point | number, pv2: Point | number) {\r\n        if (typeof(pv1) === \"number\") { // explicit\r\n            this.v1 = pv1 as number;\r\n            this.v2 = pv2 as number;\r\n        } else { // point constructor\r\n            this.p1 = pv1;\r\n            this.p2 = pv2 as Point;\r\n    \r\n            this.v1 = (pv2 as Point).x - (pv1 as Point).x;\r\n            this.v2 = (pv2 as Point).y - (pv1 as Point).y;\r\n        }\r\n        // return [ p2[0] - p1[0], p2[1] - p1[1] ];\r\n    }\r\n\r\n    // I don't know how to fit this into the constructor nicely\r\n    static fromRotation(size: number, rotation: number): Vector {\r\n        return new Vector(Math.cos(rotation), Math.sin(rotation)).scale(size);\r\n    }\r\n\r\n    get magnitude() {\r\n        if (!this._magnitude) {\r\n            this._magnitude = Math.sqrt(this.v1 * this.v1 + this.v2 * this.v2);\r\n        }\r\n        return this._magnitude;\r\n    }\r\n\r\n    equals(v: Vector) {\r\n        //return this.p1.equals(v.p1) && this.p2.equals(v.p2);\r\n        return this.v1 === v.v1 && this.v2 === v.v2;\r\n    }\r\n\r\n    dot(v: Vector) {\r\n        return this.v1 * v.v1 + this.v2 * v.v2;\r\n    }\r\n\r\n    rotate(angle: number) {\r\n        // Angle negative because of canvas coordinate origin...\r\n        let c = Math.cos(-angle);\r\n        let s = Math.sin(-angle);\r\n        return new Vector(c * this.v1 - s * this.v2, s * this.v1 + c * this.v2);\r\n        // x2 = cos(β)·x1 − sin(β)·y1\r\n        // y2 = sin(β)·x1 + cos(β)·y1\r\n    }\r\n\r\n    invert() {\r\n        return new Vector(-this.v1, -this.v2);\r\n    }\r\n\r\n    scale(scalar: number) {\r\n        return new Vector(this.v1 * scalar, this.v2 * scalar);\r\n    }\r\n\r\n    unit() {\r\n        if (this.magnitude === 0) return NULL_VECTOR;\r\n        return new Vector(this.v1 / this.magnitude, this.v2 / this.magnitude);\r\n    }\r\n\r\n    // clamps given a magnitude\r\n    clamp(min: number, max: number | null): Vector;\r\n    clamp(max: number): Vector;\r\n    clamp(min: number, max?: number | null) {\r\n        let lMin: number | null = min;\r\n        let lMax: number | null = max || null;\r\n        if (typeof(max) === \"undefined\") {\r\n            lMin = null;\r\n            lMax = min;\r\n        }\r\n        if (lMax !== null && this.magnitude > lMax) {\r\n            return this.unit().scale(lMax);\r\n        } else if (lMin !== null && this.magnitude < lMin) {\r\n            return this.unit().scale(lMin);\r\n        } else {\r\n            return this;\r\n        }\r\n    }\r\n\r\n    add(vector: Vector) {\r\n        return new Vector(this.v1 + vector.v1, this.v2 + vector.v2);\r\n    }\r\n\r\n    // TODO: use\r\n    // Projection of this over otherVector\r\n    projection(otherVector: Vector) {\r\n        return this.dot(otherVector) / otherVector.magnitude;\r\n    }\r\n\r\n    xComponent() {\r\n        return this.projection(X_VECTOR);\r\n    }\r\n\r\n    yComponent() {\r\n        return this.projection(Y_VECTOR);\r\n    }\r\n\r\n    toString() {\r\n        return `(${this.v1}, ${this.v2})`;\r\n    }\r\n}\r\n\r\nconst NULL_VECTOR = new Vector(0, 0);\r\nconst X_VECTOR = new Vector(1, 0);\r\nconst Y_VECTOR = new Vector(0, 1);","import Vector from \"./vector\";\r\n\r\n// Inmutable!\r\nexport default class Point {\r\n\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    equals(p: Point) {\r\n        return this.x === p.x && this.y === p.y;\r\n    }\r\n\r\n    distanceTo(p: Point) {\r\n        let a = p.x - this.x;\r\n        let b = p.y - this.y;\r\n        return Math.sqrt(a * a + b * b);\r\n    }\r\n\r\n    public translate(x: number, y: number): Point;\r\n    public translate(v: Vector): Point;\r\n    translate(xv: number | Vector, y?: number) {\r\n        if (xv instanceof Vector) {\r\n            return new Point(this.x + xv.v1, this.y + xv.v2);\r\n        } else {\r\n            return new Point(this.x + xv, this.y + y!);\r\n        }\r\n    }\r\n\r\n    clampX(max: number): Point;\r\n    clampX(min: number, max: number): Point;\r\n    clampX(min: number, max?: number) {\r\n        let mn: number | null = min;\r\n        if (typeof(max) === \"undefined\") {\r\n            mn = null;\r\n            max = min;\r\n        }\r\n        return this.clamp(mn, max, null, null);\r\n    }\r\n\r\n    clampY(max: number): Point;\r\n    clampY(min: number, max: number): Point;\r\n    clampY(min: number, max?: number) {\r\n        let mn: number | null = min;\r\n        if (typeof(max) === \"undefined\") {\r\n            mn = null;\r\n            max = min;\r\n        }\r\n        return this.clamp(null, null, mn, max);\r\n    }\r\n\r\n    clamp(maxX: number | null, maxY: number | null): Point;\r\n    clamp(minX: number | null, maxX: number | null, minY: number | null, maxY: number | null): Point;\r\n    clamp(minX: number | null, maxX: number | null, minY?: number | null, maxY?: number | null) {\r\n        let mnX = minX;\r\n        let mxX = maxX;\r\n        let mnY = minY;\r\n        let mxY = maxY;\r\n\r\n        let nx = this.x;\r\n        let ny = this.y;\r\n\r\n        if (typeof(minY) === \"undefined\" && typeof(maxY) === \"undefined\") {\r\n            // if just minX and maxX are present, this is a just max clamp\r\n            mnX = null;\r\n            mnY = null;\r\n            mxX = minX;\r\n            mxY = maxX;\r\n        }\r\n        if (mnX !== null && nx < mnX) {\r\n            nx = mnX;\r\n        } else if (mxX !== null && nx > mxX) {\r\n            nx = mxX;\r\n        }\r\n        if (mnY !== null && ny < mnY!) {\r\n            ny = mnY!;\r\n        } else if (mxY !== null && ny > mxY!) {\r\n            ny = mxY!;\r\n        }\r\n        return new Point(nx, ny);\r\n    }\r\n\r\n    // find closest point to this one from an array\r\n    findClosest(points: Point[]): Nullable<Point> {\r\n        if (points.length === 0) return null;\r\n        if (points.length === 1) return points[0];\r\n\r\n        let indexOfLowest = -1;\r\n        points.map(p => this.distanceTo(p)).reduce((acc, v, i) => {\r\n            if (v < acc) {\r\n                indexOfLowest = i;\r\n                return v;\r\n            } else {\r\n                return acc;\r\n            }\r\n        }, Infinity);\r\n\r\n        return points[indexOfLowest]; // point or null\r\n    }\r\n\r\n    toString() {\r\n        return `(${this.x}, ${this.y})`;\r\n    }\r\n}","import Point from \"./point\";\r\nimport Vector from \"./vector\";\r\nimport { MAX_ROUND_ERROR } from \"./constants\";\r\n\r\nconst POINT_DELTA = 1;\r\n\r\n// Should be segment?\r\nexport default class Line {\r\n\r\n    p1: Point;\r\n    p2: Point;\r\n    m: number | null;\r\n    n: number;\r\n\r\n    constructor(p1: Point, p2: Point) {\r\n        this.p1 = p1;\r\n        this.p2 = p2;\r\n        if (Math.abs(p2.x - p1.x) < MAX_ROUND_ERROR) {\r\n            // line is x = N\r\n            this.m = null;\r\n            this.n = p1.x;\r\n        } else {\r\n            this.m = (p2.y - p1.y) / (p2.x - p1.x);\r\n            this.n = p1.y - (this.m * p1.x);\r\n        }\r\n    }\r\n\r\n    // Checks if lines collide without checking segment boundaries\r\n    private collisionWithUnlimited(line: Line): Nullable<Point> {\r\n        /* cases:\r\n            normal: m != null && m != 0\r\n            2 of x = n (m === null)\r\n            2 of y = n (m === 0)\r\n            1 normal, 1 of x = n\r\n            1 normal, 1 of y = n\r\n            1 of x = n, 1 of y = n => point is [x,y]\r\n            cases of y = n can be treated as normal so we got special cases for:\r\n            2 of x = n => since m1 = null & m2 = null they go through \"same line\" branch (todo pending)\r\n            1 of x = n and 1 normal => we check!\r\n    \r\n        */\r\n        if (this.m === line.m) {\r\n            return null; // nunca se cruzan \r\n            // TODO: o son la misma!!!!!\r\n        } else if (this.m === null || line.m === null) { // any x = n???\r\n            // we treat line as x = n\r\n            let line1: Line = this;\r\n            let line2 = line;\r\n            if (line1.m === null) { // so we swap if necessary\r\n                let l = line2;\r\n                line2 = this;\r\n                line1 = l;\r\n            }\r\n            let x = line2.n; // okay...\r\n            let y = x * line1.m! + line1.n; // okay!\r\n            return new Point(x, y);\r\n        } else {\r\n            let x = (line.n - this.n) / (this.m - line.m);\r\n            let y = x * this.m + this.n;\r\n            return new Point(x, y);;\r\n        }\r\n    }\r\n\r\n    // line1 = { p1, p2 } -- line2 = { p3, p4}\r\n    // p1 = this.p1; p2 = this.p2; p3 = line.p1; p4 = line.p2\r\n    collidesWithLine(line: Line): Nullable<Point> {\r\n\r\n        let coll = this.collisionWithUnlimited(line);\r\n        if (!coll) return null;\r\n\r\n        // CHECK:\r\n        // what if dotPoint = 0 || dotPoint1 = dotSegment1\r\n        // but not in the other segment...?\r\n        // i think this wrong somehow\r\n\r\n        // is coll in segment1 and segment2?\r\n        let v1 = new Vector(this.p1, this.p2);\r\n        let dotSegment1 = v1.dot(v1);\r\n        let dotPoint1 = v1.dot(new Vector(this.p1, coll));\r\n        // if (dotPoint1 === 0) {\r\n        //     // coll = p1\r\n        //     // Because of JS float aproximations (and vectorEquals not including a delta for float aproximation)\r\n        //     // we check here and just return p1 as the coll point\r\n        //     return this.p1;\r\n        // } else if (dotPoint1 === dotSegment1) { // what if dotPoint1 ≈ dogSegment1? May return false negatives\r\n        //     return this.p2;\r\n        // }\r\n        if (dotPoint1 < 0) return null; // does not belong to segment1, so can't be valid\r\n        if (dotPoint1 > dotSegment1) return null; // does not belong to segment1, so coll is not valid\r\n\r\n        let v2 = new Vector(line.p1, line.p2);\r\n        let dotSegment2 = v2.dot(v2);\r\n        let dotPoint2 = v2.dot(new Vector(line.p1, coll));\r\n        if (dotPoint2 === 0) {\r\n            return line.p1;\r\n        } else if (dotSegment2 === dotPoint2) {\r\n            return line.p2;\r\n        }\r\n        if (dotPoint2 < 0) return null; // does not belong to segment2, so can't be valid\r\n        if (dotPoint2 < dotSegment2) return coll; // belongs segment2 (and belongs to segment1 because of dotPoint < dotSegment1)\r\n\r\n        return null;\r\n    }\r\n\r\n    // Makes sure point is WITHIN the segment defined between p1 and p2\r\n    // check /collidesWithLine/\r\n    containsPoint(point: Point): boolean {\r\n        // is coll in segment1 and segment2?\r\n        let vec = new Vector(this.p1, this.p2);\r\n        let dotSegment = vec.dot(vec);\r\n        let dotPoint = vec.dot(new Vector(this.p1, point));\r\n        if (dotPoint === 0 || dotPoint === dotSegment) return true;\r\n        //if (Math.abs(dotPoint) <= POINT_DELTA || Math.abs(dotPoint - dotSegment) <= POINT_DELTA) return true;\r\n        if (dotPoint < 0) return false; // does not belong to segment1, so can't be valid\r\n        if (dotPoint < dotSegment) return true; // does not belong to segment1, so coll is not valid\r\n        return false;\r\n    }\r\n}","import Line from \"../line\";\r\nimport Point from \"../point\";\r\nimport IElem2D from \"../interfaces/ielem2d\";\r\n\r\nexport default abstract class Geometry2D implements IElem2D {\r\n\r\n    constructor() {}\r\n\r\n    logic(delta: number) {};\r\n\r\n    abstract draw(ctx: CanvasRenderingContext2D): void;\r\n    abstract collidesWithLine(line: Line): Nullable<Point>;\r\n}","import Elem2D from \"../interfaces/ielem2d\";\r\nimport Point from \"../point\";\r\nimport Line from \"../line\";\r\nimport Geometry2D from \"./geometry2d\";\r\n\r\nexport default class Square extends Geometry2D implements Elem2D {\r\n\r\n    origin: Point;\r\n    width: number;\r\n    height: number;\r\n\r\n    // cached segment lines\r\n    tl: Line; // top \r\n    rl: Line; // right\r\n    bl: Line; // bottom\r\n    ll: Line; // left\r\n\r\n    constructor(origin: Point, width: number, height: number) {\r\n        super();\r\n\r\n        this.origin = origin\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        let ptl = this.origin;\r\n        let ptr = this.origin.translate(this.width, 0);\r\n        let pbl = this.origin.translate(0,          this.height);\r\n        let pbr = this.origin.translate(this.width, this.height);\r\n\r\n        this.tl = new Line(ptl, ptr);\r\n        this.rl = new Line(ptr, pbr);\r\n        this.bl = new Line(pbl, pbr);\r\n        this.ll = new Line(ptl, pbl);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n\r\n        ctx.strokeStyle = \"#0FF\";\r\n        ctx.strokeRect(this.origin.x, this.origin.y, this.width, this.height);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    collidesWithLine(line: Line) {\r\n        // p1 y p2 es un timo!\r\n        // hits any line hitting the square?\r\n        let hp: Nullable<Point>[] = [null, null, null, null];\r\n        hp[0] = line.collidesWithLine(this.tl);\r\n        hp[1] = line.collidesWithLine(this.rl);\r\n        hp[2] = line.collidesWithLine(this.bl);\r\n        hp[3] = line.collidesWithLine(this.ll);\r\n        // Hay que devolver uno de los puntos de colisión...\r\n        // Vamos a devolver el más cercano a line.p1... por si acaso (uwu)\r\n        return line.p1.findClosest(hp.filter((p: Nullable<Point>): p is Point => {\r\n            return p !== null;\r\n        }));\r\n    }\r\n}","import Elem2D from \"../interfaces/ielem2d\";\r\nimport Point from \"../point\";\r\nimport Line from \"../line\";\r\nimport Vector from \"../vector\";\r\nimport Geometry2D from \"./geometry2d\";\r\n\r\nexport default class Circle extends Geometry2D implements Elem2D {\r\n\r\n    center: Point;\r\n    r: number;\r\n\r\n    constructor(center: Point, r: number) {\r\n        super();\r\n\r\n        this.center = center;\r\n        this.r = r;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n\r\n        ctx.strokeStyle = \"#00F\";\r\n        ctx.beginPath();\r\n        ctx.arc(this.center.x, this.center.y, this.r, 0, 2 * Math.PI);\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    collidesWithLine(line: Line) {\r\n        // Line goes from A to B\r\n        // Circle centers at C\r\n        // We calculate AC projection onto AB and then translate A over AB for the projection amount\r\n        // Then we take C and that point and measure the distance\r\n\r\n        // θ = angle(AB, AC) - L = A·cosθ and since AB.AC = |AB||AC|cosθ => L = AB.AC / |AC|\r\n        let vec_ab = new Vector(line.p1, line.p2);\r\n        let line_unit = vec_ab.unit();\r\n        let vec_ac = new Vector(line.p1, this.center);\r\n        let proj = vec_ab.dot(vec_ac) / vec_ab.magnitude;\r\n\r\n        let point = line.p1.translate(line_unit.scale(proj));\r\n\r\n        let d = this.center.distanceTo(point);\r\n\r\n        if (d > this.r) return null;\r\n\r\n        // if d = this.r then line is tangent\r\n        // will use a differential for aprox issues\r\n        if (Math.abs(d - this.r) < 3 && line.containsPoint(point)) return point; // d ≈ this.r so return point\r\n\r\n        // here d < this.r so there's two cross points\r\n\r\n        // So we pythagoras to calculate translation of the orthogonal point\r\n        // and translate both ways thorough \\line\\\r\n        // r2 = d2 + t2\r\n        let translation = Math.sqrt(this.r * this.r - d * d);\r\n        let candidate1 = point.translate(line_unit.scale(translation));\r\n        let candidate2 = point.translate(line_unit.scale(-translation));\r\n\r\n        return line.p1.findClosest([ candidate1, candidate2 ].filter(p => line.containsPoint(p)));\r\n    }\r\n}","import kb, { KeyboardKey } from \"./keyboardController\";\r\nimport IElem2D from \"./interfaces/ielem2d\";\r\nimport Point from \"./point\";\r\nimport Line from \"./line\";\r\nimport Vector from \"./vector\";\r\nimport { CANVAS_WIDTH, CANVAS_HEIGHT } from \"./constants\";\r\nconst VECTOR_ZERO = new Vector(0, 0);\r\nconst VECTOR_UP = new Vector(0, -1);\r\nconst VECTOR_RIGHT = new Vector(1, 0);\r\nconst VECTOR_DOWN = new Vector(0, 1);\r\nconst VECTOR_LEFT = new Vector(-1, 0);\r\n\r\nconst CHAR_SIZE = 5; // must be odd\r\nconst CHAR_SIZE_OFFSET = (CHAR_SIZE - 1) / 2;\r\nconst SPEED = 10;\r\n\r\n\r\nexport default class Character implements IElem2D {\r\n\r\n    position: Point;\r\n    acceleration: Vector;\r\n    speed: Vector;\r\n\r\n    constructor(position: Point) {\r\n        this.position = position;\r\n        this.acceleration = VECTOR_ZERO;\r\n        this.speed = VECTOR_ZERO;\r\n    }\r\n\r\n    logic(delta: number): void {\r\n\r\n        let spd = VECTOR_ZERO;\r\n        if (kb.isPressed(KeyboardKey.W)) {\r\n            spd = spd.add(VECTOR_UP);\r\n        }\r\n        if (kb.isPressed(KeyboardKey.D)) {\r\n            spd = spd.add(VECTOR_RIGHT);\r\n        }\r\n        if (kb.isPressed(KeyboardKey.S)) {\r\n            spd = spd.add(VECTOR_DOWN);\r\n        }\r\n        if (kb.isPressed(KeyboardKey.A)) {\r\n            spd = spd.add(VECTOR_LEFT);\r\n        }\r\n        this.speed = spd.unit().scale(SPEED);\r\n\r\n        this.position = this.position\r\n                            .translate(this.speed)\r\n                            .clamp(\r\n                                CHAR_SIZE_OFFSET,\r\n                                CANVAS_WIDTH - CHAR_SIZE_OFFSET,\r\n                                CHAR_SIZE_OFFSET,\r\n                                CANVAS_HEIGHT - CHAR_SIZE_OFFSET\r\n                            );\r\n    }    \r\n    \r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        ctx.fillStyle = \"#000\";\r\n        ctx.fillRect( this.position.x - CHAR_SIZE_OFFSET, this.position.y - CHAR_SIZE_OFFSET, CHAR_SIZE, CHAR_SIZE);\r\n    \r\n        ctx.fillStyle = \"#0FF\";\r\n        ctx.fillRect(this.position.x, this.position.y, 1, 1);\r\n    }\r\n\r\n    collidesWithLine(line: Line) {\r\n        return null;\r\n    }\r\n\r\n\r\n}","import Geometry2D from \"./geometry2d\";\r\nimport IElem2D from \"~js/interfaces/ielem2d\";\r\nimport Line from \"~js/line\";\r\nimport Point from \"~js/point\";\r\nimport Vector from \"~js/vector\";\r\n\r\nexport default class RegularPolygon extends Geometry2D implements IElem2D {\r\n\r\n    center: Point;\r\n    sides: number;\r\n    sideLength: number;\r\n    rotation: number;\r\n\r\n    lines: Line[];\r\n\r\n    constructor(center: Point, sides: number, sideLength: number, rotation: number) {\r\n        super();\r\n\r\n        if (sides < 3) {\r\n            throw new Error(\"Polygons must have at least 3 sides\");\r\n        }\r\n\r\n        this.center     = center;\r\n        this.sides      = sides;\r\n        this.sideLength = sideLength;\r\n        this.rotation   = rotation;\r\n        this.lines = [];\r\n\r\n        // we find the points that make the polygon and join them by lines\r\n        // start from center and calculate half height and displace center that amount\r\n        // plus half a side in the other axis\r\n        let sideAngle = Math.PI * (this.sides - 2) / this.sides;\r\n\r\n        let point = this.center\r\n            .translate(\r\n                -this.sideLength / 2,\r\n                -this.sideLength / ( 2 * Math.tan(Math.PI / this.sides) )\r\n            );\r\n\r\n        let vector = new Vector(this.sideLength, 0);\r\n        let rotationAngle = Math.PI - sideAngle; // The rotation happens on the angle OUTSIDE of the figure\r\n        \r\n        // then we get the next by creating a vector of length sideLength and angle sideAngle*N\r\n        while (this.lines.length < this.sides) {\r\n            let nextPoint = point.translate(vector);\r\n            this.lines.push(new Line(point, nextPoint));\r\n\r\n            // Update values\r\n            point = nextPoint;\r\n            vector = vector.rotate(-rotationAngle); // Negative because coordinate origin of canvas (this should be abstracted away :])\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n\r\n        ctx.strokeStyle = \"#ce033a\";\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.lines[0].p1.x, this.lines[0].p1.y);\r\n        for (let i = 1; i < this.lines.length; i++) {\r\n            ctx.lineTo(this.lines[i].p1.x, this.lines[i].p1.y);\r\n        }\r\n        ctx.lineTo(this.lines[0].p1.x, this.lines[0].p1.y);\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n    \r\n    collidesWithLine(line: Line) {\r\n        // p1 y p2 es un timo!\r\n        // hits any line hitting the square?\r\n        let hp: Nullable<Point>[] = this.lines.map(l => line.collidesWithLine(l));\r\n        // Hay que devolver uno de los puntos de colisión...\r\n        // Vamos a devolver el más cercano a line.p1... por si acaso (uwu)\r\n        return line.p1.findClosest(hp.filter((p: Nullable<Point>): p is Point => {\r\n            return p !== null;\r\n        }));\r\n    }\r\n}","import kbController from \"./keyboardController\";\r\nimport { CANVAS_WIDTH, CANVAS_HEIGHT } from \"./constants\";\r\nimport Square from \"./geometry/square\";\r\n// import Circle from \"./circle\";\r\nimport Point from \"./point\";\r\nimport Vector from \"./vector\";\r\nimport Line from \"./line\";\r\nimport Circle from \"./geometry/circle\";\r\nimport Character from \"./character\";\r\nimport RegularPolygon from \"./geometry/regularPolygon\";\r\n\r\nconst ANIM = true;\r\n\r\nwindow.addEventListener(\"load\", function() {\r\nconsole.debug(\"Init main\");\r\n\r\nkbController.bind();\r\n\r\nlet canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\r\nlet ctx = canvas.getContext(\"2d\")!;\r\n\r\n\r\nlet prevTime = -1;\r\n\r\nconst CHAR = new Character(new Point(150, 150));\r\n\r\nconst MAP = [\r\n    new Square(new Point(200, 200), 100, 100),\r\n    new Circle(new Point(100, 100), 50),\r\n    new RegularPolygon(new Point(300, 100), 6, 20, 0),\r\n    CHAR,\r\n];\r\n\r\nfunction init() {\r\n    window.requestAnimationFrame(draw);\r\n}\r\n\r\nfunction draw(time: number) {\r\n    let delta = 0;\r\n    if (prevTime > 0) {\r\n        delta = time - prevTime;\r\n    }\r\n    prevTime = time;\r\n\r\n    for (let object of MAP) {\r\n        object.logic(delta);\r\n    }\r\n\r\n\r\n    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n\r\n    ctx.save();\r\n\r\n    // background\r\n    // ctx.fillStyle = \"#DDD\";\r\n    // ctx.strokeStyle = \"#000\";\r\n    // ctx.lineWidth = 10;\r\n    // ctx.strokeRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n    // ctx.restore();\r\n\r\n    for (let figure of MAP) {\r\n        figure.draw(ctx);\r\n    }\r\n    // raycast\r\n    raycast(CHAR.position, 360, 200);\r\n\r\n    if (ANIM) window.requestAnimationFrame(draw);\r\n}\r\n\r\n// 3 <= rayCount <= 360;\r\nfunction raycast(origin: Point, rayCount: number, raySize: number, firstVector?: Vector) {\r\n    if (!firstVector) {\r\n        firstVector = new Vector(1, 0);\r\n    }\r\n    // firstvector must be unitvector\r\n    ctx.save();\r\n    ctx.strokeStyle = \"#0F05\";\r\n    ctx.lineWidth = 1;\r\n    ctx.fillStyle = \"rgba(100, 100, 100, 0.5)\";\r\n\r\n    let angle = 2 * Math.PI / rayCount;\r\n\r\n    let firstEnd = null;\r\n    let rayEnd = null;\r\n    for (let i = 0; i < rayCount; i++) {\r\n        let thisAngle = i * angle;\r\n        // TODO: No recalcular cos/sin... dado que es el mismo angulo se puede calcular 1 vez\r\n        let vector = firstVector.rotate(thisAngle);\r\n        let dest = origin.translate(vector.scale(raySize)).clamp(CANVAS_WIDTH, CANVAS_HEIGHT);\r\n\r\n        // collisions?\r\n        let collidedDest: Nullable<Point> = null;\r\n        let collidedDistance = Infinity;\r\n        for (let object of MAP) {\r\n            if (object === CHAR) continue;\r\n            let coll = object.collidesWithLine(new Line(origin, dest));\r\n            if (coll) {\r\n                // ¿Is the closest collision?\r\n                let newCollDist = origin.distanceTo(coll);\r\n                if (newCollDist < collidedDistance) {\r\n                    collidedDest = coll;\r\n                    collidedDistance = newCollDist;\r\n                }\r\n            }\r\n        }\r\n        if (collidedDest) {\r\n            // draw failed ray\r\n            // ctx.save();\r\n            // ctx.beginPath();\r\n            // ctx.strokeStyle = \"#F00\";\r\n            // ctx.moveTo(collidedDest.x, collidedDest.y);\r\n            // ctx.lineTo(dest.x, dest.y);\r\n            // ctx.stroke();\r\n            // ctx.restore();\r\n            dest = collidedDest;\r\n        }\r\n        // draw correct ray\r\n        // ctx.beginPath();\r\n        // ctx.moveTo(origin.x, origin.y);\r\n        // ctx.lineTo(dest.x, dest.y);\r\n        // ctx.stroke();\r\n        // draw zones in ray\r\n        if (rayEnd) {\r\n            // draw vision zone\r\n            ctx.beginPath();\r\n            ctx.moveTo(origin.x, origin.y);\r\n            ctx.lineTo(rayEnd.x, rayEnd.y);\r\n            ctx.lineTo(dest.x, dest.y);\r\n            ctx.lineTo(origin.x, origin.y);\r\n            ctx.fill();\r\n        } else {\r\n            firstEnd = dest;\r\n        }\r\n        rayEnd = dest;\r\n    }\r\n    // another one to fill from first to last\r\n    ctx.beginPath();\r\n    ctx.moveTo(origin.x, origin.y);\r\n    ctx.lineTo(rayEnd!.x, rayEnd!.y);\r\n    ctx.lineTo(firstEnd!.x, firstEnd!.y);\r\n    ctx.lineTo(origin.x, origin.y);\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n}\r\n\r\ninit();\r\n    \r\n}); // window load"]}